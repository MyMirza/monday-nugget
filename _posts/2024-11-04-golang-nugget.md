---
layout: post
title: "Golang Nugget - November 04, 2024"
date: 2024-11-04
categories: [golang]
excerpt_separator: <!--more-->
---
Welcome to this week's edition of **Golang Nugget** your go-to source for the latest insights and updates in the world of Go programming.

This week, we dive into the powerful "benchstat" tool for analyzing Go benchmarks, ensuring your code changes are statistically significant.

Discover the intricacies of `sync.Once` and `sync.WaitGroup` for efficient concurrency management, and learn about potential security pitfalls with Go's test file naming conventions.

We also introduce Wire, a tool for automating dependency injection in Go, and discuss the benefits of hexagonal architecture for building scalable applications.

Stay updated with Go 1.23's new iteration feature, and explore the mechanics of coroutines in Go for advanced concurrency patterns.

Whether you're optimizing performance or enhancing your application's architecture, "Golang Nugget" has you covered. Enjoy the read!

<!--more-->

{% include mailerlite_golang_nugget_postpage.html %}

### [benchstat command - golang.org/x/perf/cmd/benchstat - Go Packages](https://pkg.go.dev/golang.org/x/perf/cmd/benchstat)

Benchstat is a tool for computing statistical summaries and A/B comparisons of Go benchmarks. It is designed to analyze performance changes before and after code modifications.

The tool requires input files in the Go benchmark format, which are typically generated by running benchmarks multiple times (at least 10) to ensure statistical significance. Benchstat calculates the median and confidence interval for each benchmark and compares results across different input files to identify statistically significant differences.

Benchstat offers flexible filtering and configuration options, allowing users to specify which benchmarks to compare and how to group results. It supports custom unit metadata and provides options for sorting and labeling output for clarity.

The tool emphasizes the importance of reducing noise and increasing the number of benchmark runs to improve the accuracy of statistical significance. Users are also cautioned against “multiple testing,” which can lead to false positives in detecting changes.

Here’s a basic usage example:

```bash
go test -run='^$' -bench=. -count=10 > old.txt
go test -run='^$' -bench=. -count=10 > new.txt
benchstat old.txt new.txt
```

This command sequence runs benchmarks before and after a change, then uses benchstat to compare the results.

[Read more...](https://pkg.go.dev/golang.org/x/perf/cmd/benchstat)

---

### [Go sync. Once is Simple... Does It Really?](https://victoriametrics.com/blog/go-sync-once/index.html)


The article explores the intricacies of the sync.Once primitive in Go, which ensures a function runs only once, no matter how many times it’s called or how many goroutines access it. This feature is ideal for initializing singleton resources, such as database connections or loggers.

The article explains the internal workings of sync.Once, highlighting its use of atomic operations and mutexes to manage concurrency. It also introduces enhancements in Go 1.21, such as OnceFunc, OnceValue, and OnceValues, which offer more flexible and efficient ways to handle single-execution functions, cache results, and manage errors.

Further, the article delves into implementation details, including optimizations for fast-path execution and the potential pitfalls of using compare-and-swap operations.

Here’s a simple example of sync.Once usage:

```go
var once sync.Once
var conf Config

func GetConfig() Config {
    once.Do(func() {
        conf = fetchConfig()
    })
    return conf
}
```

This code ensures `fetchConfig()` is executed only once, even if `GetConfig()` is called multiple times. The article emphasizes the importance of understanding `sync.Once` for efficient concurrency handling in Go applications.

[Read more...](https://victoriametrics.com/blog/go-sync-once/index.html)

---

### [Jia Tanning Go Code](https://www.arp242.net/jia-tan-go.html)

The Go compiler skips files ending with _test.go during normal compilation, compiling them only with the go test command. This behavior introduces a potential security vulnerability: files that appear to end with _test.go but don’t actually do so (due to hidden Unicode characters, like variation selectors) could bypass this exclusion and be compiled in regular builds, potentially allowing backdoors.

For example, a doctored user_test.go file could reduce password security by altering bcrypt cost settings. Detecting this issue is challenging, as most tools display such filenames without highlighting hidden characters—though the Git CLI can reveal them with specific settings.

Although this concern was reported to platforms like GitHub, GitLab, and BitBucket, it wasn't considered a security issue. This method could be used to hide malicious code in plain sight, as the code appears legitimate and passes tests, posing a risk if exploited by a malicious actor.

[Read more...](https://www.arp242.net/jia-tan-go.html)

---

### [Introduction to Wire: Dependency Injection in Go](https://medium.com/@piresc.dev/introduction-to-wire-dependency-injection-in-go-757e0e53189e?source=rss------golang-5)

Dependency injection (DI) is a design pattern that enhances modularity and testability by managing dependencies externally rather than within components. In Go, DI is typically implemented manually, which can become cumbersome in large applications.

Wire, a tool developed by Google, automates DI by generating code to initialize dependencies, reducing boilerplate and enhancing maintainability. Wire leverages Go's type system to ensure compile-time safety, catching errors early and improving performance by avoiding runtime reflection. This approach simplifies complex dependency graphs, making it ideal for scalable applications such as microservices.

Wire’s benefits include reduced boilerplate, improved testability, and efficient performance. However, it requires an initial learning curve and integration into build processes. Alternatives, such as Uber's Dig and Facebook's Inject, offer different trade-offs, like runtime flexibility versus compile-time safety. Wire's community support and integration with frameworks like Gin further enhance its utility.

Here’s a simple Wire example:

```go
func InitializeServer() *Server {
    wire.Build(NewDatabase, NewLogger, NewServer)
    return nil
}
```

This code snippet demonstrates how Wire automates dependency initialization by analyzing provider functions and generating the necessary wiring code.

[Read more...](https://medium.com/@piresc.dev/introduction-to-wire-dependency-injection-in-go-757e0e53189e?source=rss------golang-5)

---

### [100 GoLang Programming Mistakes and How to Avoid Them](https://blog.stackademic.com/100-golang-programming-mistakes-and-how-to-avoid-them-a9b3ee878f07?source=rss------golang-5)

Diving into Go's concurrency model can feel like navigating a maze, but avoiding common pitfalls is essential.

First, remember that while goroutines are lightweight, they aren’t free—overusing them can lead to resource exhaustion. Always use channels for communication between goroutines to prevent race conditions, but be cautious of deadlocks, which often occur when goroutines wait indefinitely for each other.

Additionally, avoid shared memory; instead, share data through channels to maintain thread safety. Finally, use sync.WaitGroup to ensure all goroutines complete before the main function exits.

Here’s a quick snippet to illustrate proper use of sync.WaitGroup:
```go
var wg sync.WaitGroup

for i := 0; i < 5; i++ {
    wg.Add(1)
    go func(i int) {
        defer wg.Done()
        fmt.Println(i)
    }(i)
}

wg.Wait()
```

This snippet ensures all goroutines finish before the program exits, preventing premature termination.

[Read more...](https://blog.stackademic.com/100-golang-programming-mistakes-and-how-to-avoid-them-a9b3ee878f07?source=rss------golang-5)

---

### [Go sync.WaitGroup and The Alignment Problem](https://victoriametrics.com/blog/go-sync-waitgroup/)

This article discusses the use of sync.WaitGroup in Go for managing concurrency, ensuring that the main goroutine waits for other goroutines to complete their tasks.

It highlights the importance of using wg.Add(1) rather than wg.Add(n) to avoid potential errors when loop logic changes, and emphasizes using defer wg.Done() to guarantee proper execution. The article also examines the internal structure of WaitGroup, explaining alignment issues with uint64 on 32-bit architectures and how Go has addressed these issues in various versions.

This article discusses the use of sync.WaitGroup in Go for managing concurrency, ensuring that the main goroutine waits for other goroutines to complete their tasks.

It highlights the importance of using wg.Add(1) rather than wg.Add(n) to avoid potential errors when loop logic changes, and emphasizes using defer wg.Done() to guarantee proper execution. The article also examines the internal structure of WaitGroup, explaining alignment issues with uint64 on 32-bit architectures and how Go has addressed these issues in various versions.

The article introduces the noCopy struct to prevent accidental copying and the atomic.Uint64 struct to ensure 8-byte alignment for atomic operations. It concludes by explaining how WaitGroup methods like Add and Wait work, and discusses trade-offs between using atomic operations and mutexes for concurrency management.

[Read more...](https://victoriametrics.com/blog/go-sync-waitgroup/)

---

### [Building a Product Management API with Go Gin and MySQL in Hexagonal Architecture](https://medium.com/@_zhanif/building-a-product-management-api-with-go-gin-and-mysql-in-hexagonal-architecture-415ff240395c?source=rss------golang-5)

Picture this: Hexagonal architecture, also known as the ports and adapters pattern, is like a well-organized orchestra where each musician (component) plays their part without stepping on each other's toes. Proposed by Dr. Alistair Cockburn in 2005, this pattern tackles the chaos of tightly coupled code by ensuring components communicate through defined ports, with adapters acting as translators to external systems like databases or APIs.

Here's the essence:

1. **Structure**: The architecture is divided into core logic (domain), ports (interfaces), and adapters (implementations). This separation ensures flexibility and testability.

2. **Database Setup**: Start by setting up a database and tables to manage product data. Use environment variables for configuration to keep things clean and maintainable.

3. **Go Project Initialization**: Initialize your Go project and install the Gin framework for handling HTTP requests.

4. **Adapters**: Implement database adapters, like `ProductRepositoryImpl`, to handle CRUD operations. These adapters translate core logic requests into database queries.

   ```go
   func (r *ProductRepositoryImpl) FindById(id string) (*domain.Product, error) {
       var product domain.Product
       row := r.db.QueryRow("SELECT id, name, price, stock FROM products WHERE id = ?", id)
       if err := row.Scan(&product.ID, &product.Name, &product.Price, &product.Stock); err != nil {
           return nil, err
       }
       return &product, nil
   }
   ```

5. **Services**: Define services like `ProductServiceImpl` to encapsulate business logic, ensuring operations like creating or updating products are handled efficiently.

6. **Handlers**: Use handlers to manage incoming HTTP requests, delegating tasks to services. This keeps your API endpoints clean and focused.

7. **Testing**: Implement unit tests for all routes to ensure reliability. Use `go test` to run these tests and validate your application’s behavior.

8. **Middleware**: Add middleware for tasks like performance testing, intercepting requests to measure execution speed.

By following these principles, you create a robust, maintainable system where changes in one part don't ripple through the entire codebase. This architecture is perfect for projects that need to adapt and scale over time.

[Read more...](https://medium.com/@_zhanif/building-a-product-management-api-with-go-gin-and-mysql-in-hexagonal-architecture-415ff240395c?source=rss------golang-5)

---

### [Ranging over functions in Go 1.23](https://eli.thegreenplace.net/2024/ranging-over-functions-in-go-123/)


Go 1.23 introduced a new feature allowing iteration over functions, enhancing the traditional for-range loop typically used with arrays, slices, and maps. This feature simplifies iterating over custom data structures, such as an association list, by using a function that returns a sequence.

The new iteration method involves defining a function that takes a yield function, which is called for each element. This approach allows for early termination of loops and supports complex iteration patterns, such as recursion in binary trees. It also supports infinite iterators, such as generating Fibonacci numbers, and can wrap existing iteration methods—like bufio.Scanner—to fit the new pattern.

The new iteration method functions as a "push" iterator, where values are pushed to a yield function, in contrast to "pull" iterators that return values on demand. This feature improves Go's ergonomics with minimal complexity, and the standard library now includes utilities for both push and pull iterators.

Here’s a simple example of the new iteration method:
```go
type AssocList[K comparable, V any] struct {
  lst []pair[K, V]
}

func (al *AssocList[K, V]) All() iter.Seq2[K, V] {
  return func(yield func(K, V) bool) {
    for _, p := range al.lst {
      if !yield(p.key, p.value) {
        return
      }
    }
  }
}

func main() {
  al := &AssocList[int, string]{}
  al.Add(10, "ten")
  al.Add(20, "twenty")
  al.Add(5, "five")

  for k, v := range al.All() {
    fmt.Printf("key=%v, value=%v\n", k, v)
  }
}
```

[Read more...](https://eli.thegreenplace.net/2024/ranging-over-functions-in-go-123/)

---

### [Book Review: System Programming Essentials with Go — A Golang Developer’s Companion to Mastering…](https://medium.com/@0xMGR/book-review-system-programming-essentials-with-go-a-golang-developers-companion-to-mastering-fa12e9872352?source=rss------golang-5)

"System Programming Essentials with Go" by Alex Rios is a comprehensive guide for Go developers interested in system programming. The book explores Go’s strengths in handling low-level tasks, such as concurrency, system calls, memory management, and network programming.

It is divided into five parts, beginning with why Go is well-suited for system programming. Subsequent sections cover interacting with the operating system, optimizing performance, building networked applications, and a capstone project focused on developing a distributed cache. The book emphasizes practical solutions, with code examples tailored for real-world applications and performance optimization.

Rios highlights Go’s concurrency model, memory management, and low-level capabilities, making this book a valuable resource for intermediate to advanced Go developers. However, it assumes prior knowledge of Go and could delve more into testing and debugging complex concurrency issues. Overall, it’s a highly recommended read for those aiming to leverage Go for high-performance, system-level applications, earning a rating of 4.5 out of 5 stars.

[Read more...](https://medium.com/@0xMGR/book-review-system-programming-essentials-with-go-a-golang-developers-companion-to-mastering-fa12e9872352?source=rss------golang-5)

---

### [Golang design: Mechanics of Coroutines](https://levelup.gitconnected.com/golang-desing-coroutines-76da4f6f5245?source=rss------golang-5)

Coroutines in Go, though not officially part of the language, can be implemented using a method by Russ Cox without altering the language itself.

The core idea involves using channels to manage input and output between the main program and the coroutine. Here's a simplified implementation.

```go
func NewCoroutine[In, Out any](f func(in In, yield func(Out) In) Out) (resume func(In) Out) {
    cin := make(chan In)
    cout := make(chan Out)

    resume = func(in In) Out {
        cin <- in
        return <-cout
    }

    yield := func(out Out) In {
        cout <- out
        return <-cin
    }

    go func() {
        cout <- f(<-cin, yield)
    }()

    return resume
}
```

In this setup, NewCoroutine returns a resume function that starts or resumes the coroutine. The coroutine uses two channels: cin for input and cout for output.

The resume function sends input to the coroutine and waits for output. The coroutine runs in a separate goroutine, using the yield function to send intermediate results back to the main program. This allows the coroutine to pause and resume, mimicking coroutine behavior.

The final output is sent back through cout when the coroutine completes. This approach provides a basic understanding of coroutine mechanics in Go.

[Read more...](https://levelup.gitconnected.com/golang-desing-coroutines-76da4f6f5245?source=rss------golang-5)